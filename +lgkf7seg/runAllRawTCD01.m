%% Run experiment to all TCD data
% To display the mean of results per label
% row = startsWith(results.name, 'tcd-s4') | startsWith(results.name, 'tcd-s5')
% fresults = results(row, :)
% varfun(@mean, results, 'InputVariables', @isnumeric, 'GroupingVariables', 'label')
% writetable(rTable, '
dir = 'data/totalcapture';
expDir = sprintf('%s/output', dir);
mkdir(expDir);
mkdir(sprintf('%s/mat', dir));
addpath('mod-lib');
addpath('mod-lib/liese3lib');
paperDir = '+papers/+lgkf7seg';

dataList = { ...
    struct('subj', 's1', 'act', 'Acting1'), ...
    struct('subj', 's1', 'act', 'Acting2'), ...
    struct('subj', 's1', 'act', 'Acting3'), ...
    struct('subj', 's1', 'act', 'freestyle1'), ...
    struct('subj', 's1', 'act', 'freestyle2'), ...
    struct('subj', 's1', 'act', 'freestyle3'), ...
    struct('subj', 's1', 'act', 'rom1'), ...
    struct('subj', 's1', 'act', 'rom2'), ...
    struct('subj', 's1', 'act', 'rom3'), ...
    struct('subj', 's1', 'act', 'walking1'), ...
    struct('subj', 's1', 'act', 'walking2'), ...
    struct('subj', 's1', 'act', 'walking3'), ...
    struct('subj', 's2', 'act', 'acting1'), ...
    struct('subj', 's2', 'act', 'acting2'), ...
    struct('subj', 's2', 'act', 'acting3'), ...
    struct('subj', 's2', 'act', 'freestyle1'), ...
    struct('subj', 's2', 'act', 'freestyle2'), ...
    struct('subj', 's2', 'act', 'freestyle3'), ...
    struct('subj', 's2', 'act', 'rom1'), ...
    struct('subj', 's2', 'act', 'rom2'), ...
    struct('subj', 's2', 'act', 'rom3'), ...
    struct('subj', 's2', 'act', 'walking1'), ...
    struct('subj', 's2', 'act', 'walking2'), ...
    struct('subj', 's2', 'act', 'walking3'), ...
    struct('subj', 's3', 'act', 'acting1'), ...
    struct('subj', 's3', 'act', 'acting2'), ...
    struct('subj', 's3', 'act', 'acting3'), ...
    struct('subj', 's3', 'act', 'freestyle1'), ...
    struct('subj', 's3', 'act', 'freestyle2'), ...
    struct('subj', 's3', 'act', 'freestyle3'), ...
    struct('subj', 's3', 'act', 'rom1'), ...
    struct('subj', 's3', 'act', 'rom2'), ...
    struct('subj', 's3', 'act', 'rom3'), ...
    struct('subj', 's3', 'act', 'walking1'), ...
    struct('subj', 's3', 'act', 'walking2'), ...
    struct('subj', 's3', 'act', 'walking3'), ...
    struct('subj', 's4', 'act', 'acting3'), ...
    struct('subj', 's4', 'act', 'freestyle1'), ...
    struct('subj', 's4', 'act', 'freestyle3'), ...
    struct('subj', 's4', 'act', 'rom3'), ...
    struct('subj', 's4', 'act', 'walking2'), ...
    struct('subj', 's5', 'act', 'acting3'), ...
    struct('subj', 's5', 'act', 'freestyle1'), ...
    struct('subj', 's5', 'act', 'freestyle3'), ...
    struct('subj', 's5', 'act', 'rom3'), ...
    struct('subj', 's5', 'act', 'walking2'), ...
};

% DATARANGE = 1:length(dataList); 
DATARANGE = 10;

% dataList = { ...
%     struct('subj', 's1', 'act', 'walking1'), ...
% };

setups = {};
% for sI = [ struct('algo', 'ckfdist', 'pI', 1, 'mI', 76, 'cI', 355), ...
%            struct('algo', 'lieekfv1', 'pI', 101, 'mI', 125, 'cI', 7), ...
%            struct('algo', 'lgckf7sv2b', 'pI', 1, 'mI', 133, 'cI', 3) ]
%     for sdI = {'av01'}
%         for initI = {'w__d'} % {'w__x'}
%             setups{end+1} = struct('est', sI.algo, ...
%                        'accData', 'w__v', 'oriData', 'w__v', 'accDataNoise', 0, ...
%                        'initSrc', initI, 'stepDetection', sdI, ...
%                        'applyPred', sI.pI, 'applyMeas', sI.mI, ...
%                        'applyCstr', sI.cI, 'P', 0.5, ...
%                        'sigmaQAcc', 1e1, 'sigmaQAngVel', 1e2, ...
%                        'c3d', true);
%         end
%     end
% end

for sI = [ struct('algo', 'ckfdist', 'pI', 1, 'mI', 76, 'cI', 355), ...
           struct('algo', 'lieekfv1', 'pI', 101, 'mI', 125, 'cI', 7), ...
           struct('algo', 'lgckf7sv2b', 'pI', 1, 'mI', 133, 'cI', 3), ...
           struct('algo', 'lgckf7sv2b', 'pI', 1, 'mI', 533, 'cI', 3), ...
           struct('algo', 'lgckf7sv2twoimu1b', 'pI', 1, 'mI', 533, 'cI', 3) ]
    for sdI = {'av01'}
        for initI = {'w__d'} % {'w__x'}
            accIOptions = {'w__s'};
            smthZPosMode = '';

            for accI = accIOptions
                setups{end+1} = struct('est', sI.algo, ...
                           'accData', accI, 'oriData', 'w__s', 'accDataNoise', 0, ...
                           'initSrc', initI, 'stepDetection', sdI, ...
                           'applyPred', sI.pI, 'applyMeas', sI.mI, ...
                           'applyCstr', sI.cI, 'P', 0.5, ...
                           'smthZPosMode', smthZPosMode, ...
                           'sigmaQAcc', 1e1, 'sigmaQAngVel', 1e2, ...
                           'c3d', true );
            end
        end
    end
end

for i = 1:length(setups)
    setups{i}.label = getLabel('NS0', setups{i});
end
           
dataN = length(dataList);
results = table();

for i = DATARANGE
    n = dataList{i};
    name = sprintf("%s-%s-%s", 'tcd', n.subj, lower(n.act));
    dataPath = sprintf('%s/mat/%s.mat', dir, name);
%     if exist(dataPath, 'file')
%         load(dataPath, 'data');
%     else
        data = struct('name', name, ...
            'fnameV', sprintf('%s/vicon/%s/%s_BlenderZXY_YmZ.bvh', dir, n.subj, lower(n.act)), ...
            'fnameS', sprintf('%s/gyroMag/%s/%s_Xsens_AuxFields.sensors', dir, n.subj, n.act), ...
            'calibFnameSensor2Body', sprintf('%s/imu/%s/%s_%s_calib_imu_bone.txt', dir, n.subj, n.subj, lower(n.act)), ...
            'calibFnameSensorW2V', sprintf('%s/imu/%s/%s_%s_calib_imu_ref.txt', dir, n.subj, n.subj, lower(n.act)) ...
            );
        
        data.dataV = mocapdb.BVHBody.loadBVHFile(data.fnameV, 'mm').toViconBody();
        data.dataV.fs = 60;
        data.calibV2W = rotm2quat([1 0 0; 0 0 -1; 0 1 0]);
        data.dataS = mocapdb.XsensBody.loadSensorFile(data.fnameS);
                        % .adjustFrame(data.calibV2W, [1 0 0 0]);
        data.dataS.fs = 60;
        data.dataX = [];
        qTCD2BM = rotm2quat([0 -1 0; -1 0 0; 0 0 -1]);
        data.calibS2B = mocapdb.XsensBody.loadCalib(data.calibFnameSensor2Body) ...
                        .adjustFrame(quatconj(qTCD2BM), [1 0 0 0], true);
        
        data.calibYawFix = struct();
        data.calibW2V = mocapdb.XsensBody.loadCalib(data.calibFnameSensorW2V);
        data.bias = struct('w__v', zeros(1, 3), 'v__v', zeros(1, 3), 'w__x', zeros(1, 3));
        save(dataPath, 'data');
%     end
    
    data.name = name;
    
    fprintf("Data %3d/%3d: %s\n", i, dataN, data.name);
    r = papers.lgkf7seg.runRawNeuRASparse01Experiment(data.dataS, ...
            data.dataV, data.calibV2W, data.calibYawFix, ...
            data.calibW2V, data.calibS2B, ...
            data.dataX, [], [], ...
            data.name, setups, expDir, '', 1, inf);
    results = [results; struct2table(r)];
end

% Append new results
dataPath = sprintf("%s/results.mat", expDir);
if exist(dataPath, 'file')
    newResults = results;
    load(dataPath);
    [C, ia, ib] = intersect(results(:,{'name', 'label'}), newResults(:,{'name', 'label'}));
    results(ia,:) = [];
    results = [results; newResults];
end
save(sprintf("%s/results.mat", expDir), 'results')

function label = getLabel(ns, setup)
    if setup.accData == 'v'
        if setup.accDataNoise == 0 
            aD = 'v';
        else
            aD = strrep(sprintf('v%.1f', setup.accDataNoise), '.', '');
        end
    else
        aD = setup.accData;
    end
    if strcmp(setup.est, 'ekfv3')
        label = sprintf("%s+A%sO%sI%s+S%s+M%02d+C%03d", ns, aD, ...
            setup.oriData, setup.initSrc, ...
            setup.stepDetection, setup.applyMeas, setup.applyCstr);
    else
        label = sprintf("%s+%s+A%sO%sI%s+S%s+P%03d+M%03d+C%03d", ns, setup.est, ...
            aD, setup.oriData, setup.initSrc, ...
            setup.stepDetection, setup.applyPred, ...
            setup.applyMeas, setup.applyCstr);
    end
end