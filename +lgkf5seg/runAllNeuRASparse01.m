% Run experiment for all NeuRA data
% NS2: use yaw offset from Vicon
%
% Example:
%       writetable(results, 'neura-sparse01/explore/results20190812.csv')
%
%% configuration
usebuffer = false; % use buffer in dir/mat if available
append_results = true; % append results if existing in buffer
export_c3d = false;

%% folder initialization
dir = 'data/neura-sparse01';
outDir = sprintf('%s/output', dir);
if ~exist(outDir, 'dir'), mkdir(outDir); end
matDir = sprintf('%s/mat', dir);
stepParamDir = '+papers/+lgkf5seg/+stepParam';
meas3DistDir = '+papers/+ckfdist2020/+dist_sim';

addpath('mod-lib');
addpath('mod-lib/liese3lib');

%% load data list
dataList = readtable(sprintf('+papers/+lgkf5seg/data-list-all.csv', dir));
dataN = size(dataList, 1);
DATARANGE = 1:dataN; % 34
% MDPI
% DATARANGE = [14, 30, 43, 44, 47, 52, 66, 110, 130, 137, 140, 149, 162];
% BioRob
% DATARANGE = [14, 42, 43, 52, 87, 104, 110, 130, 157, 158, 165, 168];

results = table();

ns = "NS2-";
setups = {
    struct('est', 'vsxsens')
    };

% for sI = [ struct('algo', 'lieekf', 'pI', 101, 'mI', 0135, 'cI', 7), ...
%          ] 
%     setups{end+1} = struct('est', sI.algo, ...
%                'accData', 'w__s', 'oriData', 'w__s', 'accDataNoise', 0, ...
%                'initSrc', 'w__v', 'stepDetection', 'av03', ...
%                'applyPred', sI.pI, 'applyMeas', sI.mI, ...
%                'applyCstr', sI.cI, 'P', 0.5, ...
%                'sigma2QAcc', 1e2, ...
%                'c3d', export_c3d );
% end

for sI = [ % final four
           struct('algo', 'ckfdist', 'pI', 421, 'mI',   76, 'cI', 355) , ...
           struct('algo', 'ckfdist', 'pI', 121, 'mI',   74, 'cI', 751) , ...
           struct('algo', 'lieekfdist', 'pI', 1121, 'mI', 4125, 'cI', 7), ...
           struct('algo', 'lieekfdist', 'pI', 32125, 'mI', 4125, 'cI', 7), ...
           ] 
    setups{end+1} = struct('est', sI.algo, ...
               'accData', 'w__s', 'oriData', 'w__s', 'accDataNoise', 0, ...
               'initSrc', 'w__v', 'stepDetection', 'av03', ...
               'applyPred', sI.pI, 'applyMeas', sI.mI, ...
               'applyCstr', sI.cI, 'P', 0.5, ...
               'sigma2QAcc', 1e2, ...
               'sigma2RLim', 10.0^mod(idivide(int32(sI.pI), 100, 'floor'), 10), ...
               'sigma2RXYPosPVLSRS', 10.0^mod(idivide(int32(sI.pI), 10, 'floor'), 10), ...
               'sigma2ROri', 10.0^(double(mod(idivide(int32(sI.pI), 1000, 'floor'),10))-2), ...
               'sigma2QGyr', 10.0^double(mod(idivide(int32(sI.pI), 10000, 'floor'),10)), ...
               'c3d', export_c3d );
end

for sI = [ struct('algo', 'ckfdist', 'pI', 421, 'mI', 270, 'cI', 355), ...
           struct('algo', 'ckfdist', 'pI', 121, 'mI', 270, 'cI', 751), ...
           struct('algo', 'lieekfdist', 'pI',  1121, 'mI', 4345, 'cI', 7) , ... 
           struct('algo', 'lieekfdist', 'pI', 32125, 'mI', 4345, 'cI', 7) , ... 
           ] 
    for s3dSigma = 0.1 % [0.01:0.01:0.1 0.15:0.05:0.2]
        for s3dI = 1 % 1:5
            setups{end+1} = struct('est', sI.algo, ...
                       'accData', 'w__s', 'oriData', 'w__s', 'accDataNoise', 0, ...
                       'initSrc', 'w__v', 'stepDetection', 'av03', ...
                       'applyPred', sI.pI, 'applyMeas', sI.mI, ...
                       'applyCstr', sI.cI, 'P', 0.5, 'sigma2QAcc', 1e2, ...
                       'sigma2RLim', 10.0^mod(idivide(int32(sI.pI), 100, 'floor'), 10), ...
                       'sigma2RXYPosPVLSRS', 10.0^mod(idivide(int32(sI.pI), 10, 'floor'), 10), ...
                       'sigma2ROri', 10.0^(double(mod(idivide(int32(sI.pI), 1000, 'floor'),10))-2), ...
                       'sigma2QGyr', 10.0^double(mod(idivide(int32(sI.pI), 10000, 'floor'),10)), ...
                       'c3d', export_c3d, ...
                       'sim3Dist', s3dI, 'sim3DistSigma', s3dSigma);
        end
    end
end

%% run only one for straight walk
% for sI = [ struct('algo', 'ckfdist',    'pI', 100421, 'mI', 270, 'cI', 355), ...
%            struct('algo', 'lieekfdist', 'pI', 132125, 'mI', 4345, 'cI', 7) , ... 
%            struct('algo', 'ckfdist',    'pI', 200421, 'mI', 270, 'cI', 355), ...
%            struct('algo', 'lieekfdist', 'pI', 232125, 'mI', 4345, 'cI', 7) , ... 
%            struct('algo', 'ckfdist',    'pI', 300421, 'mI', 270, 'cI', 355), ...
%            struct('algo', 'lieekfdist', 'pI', 332125, 'mI', 4345, 'cI', 7) , ... 
%            struct('algo', 'ckfdist',    'pI', 400421, 'mI', 270, 'cI', 355), ...
%            struct('algo', 'lieekfdist', 'pI', 432125, 'mI', 4345, 'cI', 7) , ... 
%            struct('algo', 'ckfdist',    'pI', 500421, 'mI', 270, 'cI', 355), ...
%            struct('algo', 'lieekfdist', 'pI', 532125, 'mI', 4345, 'cI', 7) , ... 
%            struct('algo', 'ckfdist', 'pI', 421, 'mI',   76, 'cI', 355) , ...
%            struct('algo', 'lieekfdist', 'pI', 32125, 'mI', 4125, 'cI', 7), ...
%            ] 
%     for s3dSigma = 0.1
%         s3dI = double(mod(idivide(int32(sI.pI), 100000, 'floor'),10));
%         setups{end+1} = struct('est', sI.algo, ...
%                    'accData', 'w__s', 'oriData', 'w__s', 'accDataNoise', 0, ...
%                    'initSrc', 'w__v', 'stepDetection', 'av03', ...
%                    'applyPred', sI.pI, 'applyMeas', sI.mI, ...
%                    'applyCstr', sI.cI, 'P', 0.5, 'sigma2QAcc', 1e2, ...
%                    'sigma2RLim', 10.0^mod(idivide(int32(sI.pI), 100, 'floor'), 10), ...
%                    'sigma2RXYPosPVLSRS', 10.0^mod(idivide(int32(sI.pI), 10, 'floor'), 10), ...
%                    'sigma2ROri', 10.0^(double(mod(idivide(int32(sI.pI), 1000, 'floor'),10))-2), ...
%                    'sigma2QGyr', 10.0^double(mod(idivide(int32(sI.pI), 10000, 'floor'),10)), ...
%                    'c3d', export_c3d, ...
%                    'sim3Dist', s3dI, 'sim3DistSigma', s3dSigma);
%     end
% end

for i = 1:length(setups)
    setups{i}.label = getLabel(setups{i}, ns);
end

for i = DATARANGE
    n = table2struct(dataList(i, :));
    name = sprintf("%s%s-%s", ns, n.subj, n.act);
    fprintf("Data %3d/%3d: %s\n", i, dataN, name);
    
    % load data
    data = mocapdb.loadNeuRaTrialData(dir, n.subj, n.act, usebuffer);
    % preprocess the data
    [imuData, gfrAcc, step] = papers.lgkf5seg.preprocessing( ...
                    data.dataS, data.dataV, ...
                    data.calibYawFix, data.revStepDetect, ...
                    sprintf("%s/%s-preproc.mat", outDir, name));
    % run experiment for each configuration listed in setups
    actBody = data.dataV.togrBody(1:data.dataV.nSamples, ...
        {'name', name, 'oriUnit', 'deg', 'lnSymbol', '-', 'ptSymbol', '*', ...
         'fs', data.dataV.fs, 'xyzColor', {'m', 'y', 'c'}});
    
    r = papers.lgkf5seg.runExperiment(imuData, gfrAcc, step, ...
        actBody, data.dataX, setups, outDir, stepParamDir, meas3DistDir);
    results = [results; struct2table(r)];
end

% Append new results
if append_results
    dataPath = sprintf("%s/results.mat", outDir);
    if exist(dataPath, 'file')
        newResults = results;
        load(dataPath);
        [C, ia, ib] = intersect(results(:,{'name', 'label'}), newResults(:,{'name', 'label'}));
        results(ia,:) = [];
        results = [results; newResults];
    end
end
save(sprintf("%s/results.mat", outDir), 'results')

function label = getLabel(setup, prefix)    
    if strcmp(setup.est, 'vsxsens')
        label = sprintf("%sviconvsxsens", prefix);
    else
        label = sprintf("%s%s+A%sO%sI%s+S%s+P%03d+M%03d+C%03d", prefix, setup.est, ...
                setup.accData, setup.oriData, setup.initSrc, ...
                setup.stepDetection, setup.applyPred, ...
                setup.applyMeas, setup.applyCstr);
    end
end